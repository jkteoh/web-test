/// <reference types="hoist-non-react-statics" />
/// <reference types="node" />
/// <reference types="prop-types" />
/// <reference types="react" />
/// <reference types="scheduler" />

import * as React from 'react';
import { DefaultTheme, GlobalStyleComponent } from 'styled-components';

/**
 * Custom hook to keep prop and state values in sync.
 * @argument value The outside value (taking precedence over internal state value).
 * @argument onChange A function that synchronises internal state value with consumer.
 */
export declare function useSynchronisedPropState<T>(value: T, onChange: ((updatedValue: T) => void) | undefined): [
	typeof value,
	React.Dispatch<React.SetStateAction<T>>
];
export interface IRadioGroupContext {
	name: string;
	onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
	value: string | undefined;
}
export declare const useRadioGroupContext: () => IRadioGroupContext;
/**
 * Custom hook to check for clicks outside a certain element.
 * @argument ref The ref to monitor
 * @argument onClickOutside A function to execute when a click was detected outside the ref
 * @argument validateClickOutside A function that validates whether the onClickOutside function should be executed
 */
export declare function useClickOutsideRef(ref: React.MutableRefObject<HTMLElement | null>, onClickOutside: (event: MouseEvent) => void, validateClickOutside?: () => boolean): void;
/**
 * Function that returns a rgba string based on the opacity passed in.
 * @param {number} [opacity=1]    opacity Opacity of range 0 to 1.
 */
export declare type PrimitiveColorGenFunc = (opacity?: number) => string;
export interface PrimitiveColorMap {
	WHITE: PrimitiveColorGenFunc;
	BLACK: PrimitiveColorGenFunc;
	GRAY_50: PrimitiveColorGenFunc;
	GRAY_100: PrimitiveColorGenFunc;
	GRAY_200: PrimitiveColorGenFunc;
	GRAY_300: PrimitiveColorGenFunc;
	GRAY_400: PrimitiveColorGenFunc;
	GRAY_500: PrimitiveColorGenFunc;
	GRAY_600: PrimitiveColorGenFunc;
	GRAY_700: PrimitiveColorGenFunc;
	GRAY_800: PrimitiveColorGenFunc;
	GRAY_900: PrimitiveColorGenFunc;
	TURQUOISE_50: PrimitiveColorGenFunc;
	TURQUOISE_100: PrimitiveColorGenFunc;
	TURQUOISE_200: PrimitiveColorGenFunc;
	TURQUOISE_300: PrimitiveColorGenFunc;
	TURQUOISE_400: PrimitiveColorGenFunc;
	TURQUOISE_500: PrimitiveColorGenFunc;
	TURQUOISE_600: PrimitiveColorGenFunc;
	TURQUOISE_700: PrimitiveColorGenFunc;
	TURQUOISE_800: PrimitiveColorGenFunc;
	TURQUOISE_900: PrimitiveColorGenFunc;
	BLUE_50: PrimitiveColorGenFunc;
	BLUE_100: PrimitiveColorGenFunc;
	BLUE_200: PrimitiveColorGenFunc;
	BLUE_300: PrimitiveColorGenFunc;
	BLUE_400: PrimitiveColorGenFunc;
	BLUE_500: PrimitiveColorGenFunc;
	BLUE_600: PrimitiveColorGenFunc;
	BLUE_700: PrimitiveColorGenFunc;
	BLUE_800: PrimitiveColorGenFunc;
	BLUE_900: PrimitiveColorGenFunc;
	GREEN_50: PrimitiveColorGenFunc;
	GREEN_100: PrimitiveColorGenFunc;
	GREEN_200: PrimitiveColorGenFunc;
	GREEN_300: PrimitiveColorGenFunc;
	GREEN_400: PrimitiveColorGenFunc;
	GREEN_500: PrimitiveColorGenFunc;
	GREEN_600: PrimitiveColorGenFunc;
	GREEN_700: PrimitiveColorGenFunc;
	GREEN_800: PrimitiveColorGenFunc;
	GREEN_900: PrimitiveColorGenFunc;
	YELLOW_50: PrimitiveColorGenFunc;
	YELLOW_100: PrimitiveColorGenFunc;
	YELLOW_200: PrimitiveColorGenFunc;
	YELLOW_300: PrimitiveColorGenFunc;
	YELLOW_400: PrimitiveColorGenFunc;
	YELLOW_500: PrimitiveColorGenFunc;
	YELLOW_600: PrimitiveColorGenFunc;
	YELLOW_700: PrimitiveColorGenFunc;
	YELLOW_800: PrimitiveColorGenFunc;
	YELLOW_900: PrimitiveColorGenFunc;
	RED_50: PrimitiveColorGenFunc;
	RED_100: PrimitiveColorGenFunc;
	RED_200: PrimitiveColorGenFunc;
	RED_300: PrimitiveColorGenFunc;
	RED_400: PrimitiveColorGenFunc;
	RED_500: PrimitiveColorGenFunc;
	RED_600: PrimitiveColorGenFunc;
	RED_700: PrimitiveColorGenFunc;
	RED_800: PrimitiveColorGenFunc;
	RED_900: PrimitiveColorGenFunc;
}
export declare type PRIMITIVE_COLOR_MAP = keyof PrimitiveColorMap;
export interface ButtonProps {
	/**
	 * React children
	 */
	children?: React.ReactNode;
	/**
	 * Disabled State
	 */
	disabled?: boolean;
	/**
	 * Round Button (For Icon Only Button)
	 */
	round?: boolean;
	/**
	 * Dark Mode
	 */
	dark?: boolean;
	/**
	 * Loading State
	 */
	loading?: boolean;
	/**
	 * Button Color. Support: ML_Color | css color | 'primary', 'secondary'
	 */
	color?: PRIMITIVE_COLOR_MAP | "primary" | "secondary" | string;
	/**
	 * Button type. Supports: submit, button, reset
	 */
	type?: "submit" | "button" | "reset";
	/**
	 * CSS Style
	 */
	style?: React.CSSProperties;
	/**
	 * Custom class to override styling
	 */
	className?: string;
	/**
	 * Callback when click on button
	 */
	onClick?: (e?: React.MouseEvent<HTMLButtonElement>) => void;
	/**
	 * Should the button flex?
	 */
	shouldFlex?: boolean;
	/**
	 * If `true`, the button will take up the full width of its container.
	 */
	fullWidth?: boolean;
}
export declare const Button: React.FunctionComponent<ButtonProps>;
export interface ChipProps {
	children: React.ReactNode;
	dark?: boolean;
	disabled?: boolean;
	selected?: boolean;
	visited?: boolean;
	onSelect?: (selected: boolean) => void;
	className?: string;
}
export interface BannerThemeBase {
	dark?: boolean;
}
export interface BannerThemeLifecycle extends BannerThemeBase {
	type: "lifecycle";
	flavour?: never;
	imageUrl?: string;
}
export interface BannerThemeRegular extends BannerThemeBase {
	type: "regular";
	flavour?: never;
	imageUrl?: string;
}
export interface BannerThemeNotification extends BannerThemeBase {
	type: "notification";
	flavour: "informational" | "positive" | "warning" | "alert";
	imageUrl?: never;
}
export declare type BannerTheme = BannerThemeLifecycle | BannerThemeRegular | BannerThemeNotification;
export interface ActionChipItem {
	key: string;
	component: React.ReactElement<ChipProps>;
}
export interface BannerBaseProps {
	actionChips?: ActionChipItem[];
	className?: string;
	dark?: boolean;
	imageUrl?: string;
	style?: React.CSSProperties;
	styleProps: BannerTheme;
	text?: string;
	title?: string;
}
export interface BannerWithTextProps extends BannerBaseProps {
	children?: never;
	text: string;
}
export interface BannerWithChildrenProps extends BannerBaseProps {
	children: React.ReactNode;
	text?: never;
}
export declare type BannerProps = BannerWithTextProps | BannerWithChildrenProps;
export declare const Banner: React.FunctionComponent<BannerProps>;
export declare type MLIconNames = "add" | "addCircle" | "addUser" | "alert" | "arrowDown" | "arrowDownCircle" | "arrowLeft" | "arrowLeftCircle" | "arrowRight" | "arrowRightCircle" | "arrowUp" | "arrowUpCircle" | "atm" | "bank" | "basicCoverage" | "bell" | "bestCoverage" | "betterCoverage" | "birthday" | "bitcoin" | "book" | "burger" | "calendar" | "camera" | "cameraReverse" | "car" | "card" | "chartBox" | "chat" | "check" | "checkCircle" | "checkCircleOutline" | "checkboxChecked" | "checkboxIndeterminate" | "checkboxUnchecked" | "cheque" | "chevronDown" | "chevronLeft" | "chevronRight" | "chevronUp" | "clock" | "clockAlarm" | "close" | "closeCircle" | "cloud" | "copy" | "creditscore" | "crypto" | "document" | "documentAlt" | "download" | "edit" | "education" | "endQuote" | "expand" | "externalLink" | "ff15" | "gift" | "giftCard" | "greaterGood" | "growth" | "help" | "hide" | "history" | "home" | "id" | "income" | "info" | "insurance" | "internet" | "lightbulb" | "lightning" | "like" | "likeSelected" | "link" | "location" | "locked" | "mail" | "marketplace" | "minCoverage" | "money" | "moneyCircle" | "moneylion" | "moneylionInverse" | "moreHorizontal" | "moreVertical" | "pause" | "pauseFill" | "paymentDeclined" | "paymentInProgress" | "paymentSettled" | "pdf" | "phone" | "piechart" | "plan" | "play" | "playBack" | "playBackFill" | "playFill" | "playForward" | "playForwardFill" | "playPause" | "playPauseFill" | "qrCode" | "radioButtonChecked" | "radioButtonUnchecked" | "receipt" | "refresh" | "remove" | "removeCircle" | "rocket" | "roundups" | "rw15" | "satchell" | "search" | "searchDot" | "security" | "send" | "settings" | "settingsAlt" | "share" | "shareAlt" | "show" | "sound" | "soundFill" | "soundMute" | "soundMuteFill" | "spending" | "star" | "startQuote" | "today" | "todayDate" | "transferHorizontal" | "transferVertical" | "trash" | "unlocked" | "upload" | "user" | "wallet" | "warning" | "we" | "wifi" | "wifiOff";
export interface IconProps {
	/**
	 * Icon size
	 */
	size?: number;
	/**
	 * Dark Mode UI (for coloured background)
	 */
	dark?: boolean;
	/**
	 * Icon alignment right
	 */
	right?: boolean;
	/**
	 * Icon alignment left
	 */
	left?: boolean;
	/**
	 * Spin icon
	 */
	spin?: boolean;
	/**
	 * Color Code:  ML Color, primary, secondary, Color CSS
	 */
	color?: PRIMITIVE_COLOR_MAP | "primary" | "secondary" | "tertiary" | string;
	/**
	 * CSS Style
	 */
	style?: React.CSSProperties;
	/**
	 * Icon name
	 */
	children: MLIconNames | React.ReactElement | string;
	/**
	 * Callback when click on icon
	 */
	onClick?: (e: React.MouseEvent<HTMLInputElement>) => void;
	/**
	 * Skip the visibility transition?
	 */
	shouldSkipTransition?: boolean;
	/**
	 * Custom class name
	 */
	className?: string;
}
export declare const MLIcon: React.FunctionComponent<IconProps>;
export declare type ChipIconProps = Omit<IconProps, "color" | "skipTransition" | "dark">;
declare const ChipIcon: React.FunctionComponent<ChipIconProps>;
export declare type TextSize = "XXLarge" | "XLarge" | "Large" | "Medium" | "Small" | "XSmall" | "XXSmall";
export interface TypographyProps {
	/**
	 * React children
	 */
	children?: React.ReactNode;
	/**
	 * CSS Style
	 */
	style?: React.CSSProperties;
	/**
	 * Color Code:  ML Color, primary, secondary, Color CSS
	 */
	color?: PRIMITIVE_COLOR_MAP | "primary" | "secondary" | "tertiary" | string;
	/**
	 * Text Size
	 */
	size?: TextSize;
	/**
	 * Custom class name
	 */
	className?: string;
}
export interface LabelProps extends TypographyProps {
	/**
	 * Text Size
	 */
	size?: Exclude<TextSize, "XXLarge" | "XLarge">;
}
export declare const Label: import("styled-components").StyledComponent<"span", any, LabelProps, never>;
export declare type ChipTextProps = Omit<LabelProps, "size" | "color">;
declare const ChipText: React.FunctionComponent<ChipTextProps>;
declare const ChipCompounded: import("react").FunctionComponent<ChipProps> & {
	Icon: typeof ChipIcon;
	Text: typeof ChipText;
};
export interface CheckboxProps {
	/**
	 * Checkbox ID
	 */
	id?: string;
	/**
	 * Disabled mode
	 */
	disabled?: boolean;
	/**
	 * Button Color: ML Color, primary, secondary, css color
	 */
	color?: PRIMITIVE_COLOR_MAP | "primary" | "secondary" | string;
	/**
	 * Dark Mode UI (for colored background)
	 */
	dark?: boolean;
	/**
	 * Initial interminate state
	 */
	interdeterminate?: boolean;
	/**
	 * Input Initial Value
	 */
	value?: boolean;
	/**
	 * Callback for value changed
	 */
	onChange?: (event: React.ChangeEvent<HTMLInputElement>) => void;
	/**
	 * Class name for to overide styling
	 */
	className?: string;
}
export declare const Checkbox: React.FunctionComponent<CheckboxProps>;
export interface CodeInputProps {
	/**
	 * HTML Input Type
	 */
	type?: "text" | "number" | "password";
	/**
	 * Length of code
	 */
	length: number;
	/**
	 * Default value
	 */
	value?: string;
	/**
	 * Input placeholder
	 */
	placeholder?: string;
	/**
	 * Disabled mode
	 */
	disabled?: boolean;
	/**
	 * To override existing styling
	 */
	style?: React.CSSProperties;
	/**
	 * Success state
	 */
	success?: boolean;
	/**
	 * Error state
	 */
	error?: boolean;
	/**
	 * Dark mode
	 */
	dark?: boolean;
	/**
	 * Array of rules for validations
	 */
	rules?: ((val: string) => boolean | string)[];
	/**
	 * Callback for value changed
	 */
	onChange?: (val: string) => void;
	/**
	 * Callback for when code is completed
	 */
	onComplete?: (val?: string) => void;
	/**
	 *  Callback for when you need to reset the code value in the state
	 */
	resetCode?: (callback: () => void) => void;
	/**
	 * Should only accept numbers (useful for type "password-number" use case).
	 */
	numbersOnly?: boolean;
	/**
	 * Custom class name to override existing style
	 */
	className?: string;
}
export declare const CodeInput: React.FunctionComponent<CodeInputProps>;
export interface IDialogContext {
	closeDialog: () => void;
	currentDialogIdx: number;
	isOpen: boolean;
	setCurrentDialogIdx: (idx: number) => void;
	stopPrompting: () => void;
}
declare const DialogContext: React.Context<IDialogContext>;
export interface DialogProps {
	/**
	 * React children (can optionally be a function (render props)
	 * where we'll inject IDialogContext)
	 */
	children: React.ReactNode | ((renderProps: IDialogContext) => React.ReactNode);
	/**
	 * Function passed in by consumer which is called when dialog closes  (e.g. for
	 * syncing state between consumer and component).
	 */
	onCloseDialog?: () => void;
	/**
	 * Can the user dismiss the dialog without any interaction? e.g.
	 * by clicking outside the dialog to hide it.
	 */
	isDismissable?: boolean;
	/**
	 * Custom class name
	 */
	className?: string;
}
declare const Dialog: React.FunctionComponent<DialogProps>;
export declare type DialogButtonProps = Omit<ButtonProps, "shouldFlex">;
declare const DialogButton: React.FunctionComponent<DialogButtonProps>;
export interface DialogButtonContainerProps {
	children: React.ReactNode;
	direction: "column" | "row";
	className?: string;
}
declare const DialogButtonContainer: React.FunctionComponent<DialogButtonContainerProps>;
export declare type DialogImageSrcType = string;
export declare type DialogImageAltType = string;
export interface DialogImageProps {
	src: DialogImageSrcType;
	alt: DialogImageAltType;
	className?: string;
}
declare const DialogImage: React.FunctionComponent<DialogImageProps>;
export interface DialogManagerProps {
	/**
	 * Class name
	 */
	className?: string;
	/**
	 * An HTMLElement where we will render the DialogManager in. If omitted
	 * we will create one in the body ourselves.
	 */
	elDialogRoot?: HTMLElement;
	/**
	 * A function that the consumer passes in which exposes the "showDialogs" function
	 * to the outside. Ideally the consumer makes this globally available in its own
	 * app through a global store or variable.
	 */
	registerShowDialogsFn: (showDialogs: Function) => void;
	/**
	 * Boolean indicating whether we will render the backdrop.
	 */
	shouldRenderBackdrop?: boolean;
}
declare const DialogManager: React.FunctionComponent<DialogManagerProps>;
export interface DialogTextProps {
	text: string;
	className?: string;
}
declare const DialogText: React.FunctionComponent<DialogTextProps>;
export interface DialogTitleProps {
	text: string;
	className?: string;
}
declare const DialogTitle: React.FunctionComponent<DialogTitleProps>;
export declare type DialogCompoundedTypeButton = typeof DialogButton & {
	Container: typeof DialogButtonContainer;
};
export declare type DialogCompoundedType = typeof Dialog & {
	Button: DialogCompoundedTypeButton;
	Context: typeof DialogContext;
	Image: typeof DialogImage;
	Manager: typeof DialogManager;
	Text: typeof DialogText;
	Title: typeof DialogTitle;
};
declare const DialogCompounded: DialogCompoundedType;
export interface LoadingProps {
	style: React.CSSProperties;
}
export declare const LoadingIcon: React.FunctionComponent<LoadingProps>;
export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
	/**
	 * A function called before updating the `inputValue` state. This could be useful if you'd like
	 * to transform the `inputValue` before updating the state. It should either return:
	 *
	 *  - `true`: The value is accepted as is and will be written to component's state.
	 *  - `false`: The value is not accepted and state will NOT be updated.
	 *  - `string`: The value is transformed, the transformed value will be written to component's state.
	 */
	beforeUpdateValue?: (value: string) => boolean | string;
	/**
	 * Leading Icon. Accepts MLIconNames
	 */
	leadingIcon?: MLIconNames;
	/**
	 * Trailing Icon. Accepts MLIconNames
	 */
	trailingIcon?: MLIconNames;
	/**
	 * Input label (e.g First Name, Last Name, Email, etc)
	 */
	label: string;
	/**
	 * Input value
	 */
	value?: string;
	/**
	 * Validation rules is an Array of functions. Each function should return a boolean or string.
	 *
	 * The function should accept the `value` as an argument and return `true` if the input value is valid.
	 *
	 * The input will be considered invalid if the function return `false` or `string` value.
	 * If `raw` is true the `value` will contain raw value.
	 *
	 * `error` and `success` state will be overwritten by the validation rules.
	 */
	rules?: ((value: string) => string | boolean)[];
	/**
	 * Input suffix
	 */
	suffix?: string;
	/**
	 * Input prefix
	 */
	prefix?: string;
	/**
	 * Assistive text
	 */
	assistiveText?: string;
	/**
	 * Input success text
	 */
	successText?: string;
	/**
	 * Input error text
	 */
	errorText?: string;
	/**
	 * Error state
	 */
	error?: boolean;
	/**
	 * Success state
	 */
	success?: boolean;
	/**
	 * Loading state
	 */
	loading?: boolean;
	/**
	 * Dark Mode UI (for colored background)
	 */
	dark?: boolean;
	/**
	 * Input Mask (Refer Mask Section)
	 */
	mask?: string;
	/**
	 * Return unmasked value (onChange callback)
	 */
	raw?: boolean;
	/**
	 * Custom styling properties for input component
	 */
	inputStyle?: React.CSSProperties;
}
export declare const Input: React.FunctionComponent<InputProps>;
export interface RadioProps {
	/**
	 * Radio ID
	 */
	id?: string;
	/**
	 * Disabled mode
	 */
	disabled?: boolean;
	/**
	 * Button Color:  ML Color, primary, secondary, css color
	 */
	color?: PRIMITIVE_COLOR_MAP | "primary" | "secondary" | string;
	/**
	 * Dark Mode UI (for coloured background)
	 */
	dark?: boolean;
	/**
	 * Input inital value
	 */
	value?: string;
	/**
	 * Radio name (overrided by radio group name)
	 */
	name?: string;
	/**
	 * Initial state of the radio button
	 */
	checked?: boolean;
	/**
	 * Callback for value changed
	 */
	onChange?: (event: React.ChangeEvent<HTMLInputElement>) => void;
	/**
	 * Custom class to override styling
	 */
	className?: string;
}
export declare const Radio: React.FunctionComponent<RadioProps>;
export interface RadioGroupProps {
	/**
	 * React children
	 */
	children?: React.ReactNode;
	/**
	 * Radio group name (to be populated to radio buttons)
	 */
	name: string;
	/**
	 * Input Initial Value
	 */
	value?: string | undefined;
	/**
	 * Callback for value changed
	 */
	onChange?: (event: React.ChangeEvent<HTMLInputElement>) => void;
	/**
	 * Custom class name
	 */
	className?: string;
}
export declare const RadioGroup: React.FunctionComponent<RadioGroupProps>;
export interface StepperProps {
	/**
	 * Minimum permitted value
	 */
	min?: number;
	/**
	 * Maximum permitted value
	 */
	max?: number;
	/**
	 * Stepper initial value
	 */
	value?: number;
	/**
	 * Callback for value changed
	 */
	onChange?: (number: any) => void;
	/**
	 * Background Color
	 */
	dark?: boolean;
	/**
	 * Disabled mode
	 */
	disabled?: boolean;
	/**
	 * Custom class name to override styling
	 */
	className?: string;
}
export declare const Stepper: React.FunctionComponent<StepperProps>;
export interface SliderProps {
	/**
	 * Intial value
	 */
	value: number;
	/**
	 * Minimum permitted value
	 */
	min: number;
	/**
	 * Maximum permitted value
	 */
	max: number;
	/**
	 * Stepping interval
	 */
	step?: number;
	/**
	 * If true will show discrete point
	 */
	showDiscretePoints?: boolean;
	/**
	 * Whether to show the slider progress line or not
	 */
	shouldShowProgress?: boolean;
	/**
	 * Dark mode
	 */
	dark?: boolean;
	/**
	 * Callback for value changed
	 */
	onChange?: (event: React.ChangeEvent<HTMLInputElement>) => void;
	/**
	 * To specify a CSS class
	 */
	className?: string;
}
export declare const Slider: React.FunctionComponent<SliderProps>;
export interface SwitchProps {
	/**
	 * Disabled mode
	 */
	disabled?: boolean;
	/**
	 * Button color: ML Color, primary, secondary, css color
	 */
	color?: PRIMITIVE_COLOR_MAP | "primary" | "secondary" | string;
	/**
	 * Dark Mode UI (for colored background)
	 */
	dark?: boolean;
	/**
	 * Switch initial value
	 */
	value?: boolean;
	/**
	 * Callback for value changed
	 */
	onChange?: (event: React.ChangeEvent<HTMLInputElement>) => void;
	/**
	 * Custom class name to override styling
	 */
	className?: string;
	/**
	 * Custom style props to override styling
	 */
	style?: React.CSSProperties;
}
export declare const Switch: React.FunctionComponent<SwitchProps>;
export interface OptionProps {
	value: string;
}
declare const Option: React.FC<OptionProps>;
export interface SelectProps {
	/**
	 * Select label
	 */
	label: string;
	/**
	 * If true, option can be searched via input
	 */
	isSearchable?: boolean;
	/**
	 * Select success state
	 */
	success?: boolean;
	/**
	 * Select error state
	 */
	error?: boolean;
	/**
	 * Assitive text
	 */
	assistiveText?: string;
	/**
	 * Success text (will overide `assistiveText` if `success` is true)
	 */
	successText?: string;
	/**
	 * Error text (will overide `assistiveText` if `error` is true)
	 */
	errorText?: string;
	/**
	 * Custom class name
	 */
	className?: string;
	/**
	 * Custom style properties
	 */
	style?: React.CSSProperties;
	/**
	 * Dark Mode UI (for colored background)
	 */
	dark?: boolean;
	/**
	 * Callback for value changed
	 */
	onChange?: (value: string) => void;
	/**
	 * Callback for input text value changed
	 */
	onInputChange?: (e: React.ChangeEvent<HTMLInputElement>) => void;
}
declare const SelectCompouned: import("react").FunctionComponent<SelectProps> & {
	Option: typeof Option;
};
export interface ListBulletProps {
	/**
	 * Text
	 */
	text?: string;
	/**
	 * Image Url
	 */
	url?: string;
	/**
	 * Squared borders
	 */
	square?: boolean;
	/**
	 * Image Url
	 */
	color?: string;
	/**
	 * ML Icon name
	 */
	icon?: string;
}
export interface ListProps {
	/**
	 * React children
	 */
	children?: React.ReactNode;
	/**
	 * Background Color
	 */
	dark?: boolean;
	/**
	 * Bullet Options
	 */
	bullet?: ListBulletProps;
	/**
	 * Divider Options
	 */
	divider?: "full" | "none";
	/**
	 * Custom class name
	 */
	className?: string;
}
declare const List: React.FunctionComponent<ListProps>;
export interface ListItemProps {
	/**
	 * React children
	 */
	children?: React.ReactNode;
	/**
	 * Bullet Options
	 */
	bullet?: ListBulletProps;
	/**
	 * Divider Options
	 */
	divider?: "full" | "none";
	/**
	 * Custom class name
	 */
	className?: string;
	/**
	 * Custom class name
	 */
	onClick?: (e?: React.MouseEvent<HTMLElement>) => void;
	/**
	 * Disables various user interaction effects on the item
	 */
	disabledEffects?: ("hover" | "focus" | "active" | "visited")[];
}
declare const ListItem: React.FunctionComponent<ListItemProps>;
export interface ListLabelProps {
	/**
	 * Side content
	 */
	children?: React.ReactNode;
	/**
	 * Main Label
	 */
	main?: string | React.ReactNode;
	/**
	 * Sub Label
	 */
	sub?: string | React.ReactNode;
	/**
	 * Custom class name
	 */
	className?: string;
}
declare const ListLabel: React.FunctionComponent<ListLabelProps>;
export interface ListMetaProps {
	/**
	 * Main Label
	 */
	main?: string | React.ReactNode;
	/**
	 * Sub Label
	 */
	sub?: string | React.ReactNode;
	/**
	 * Custom class name
	 */
	className?: string;
}
declare const ListMeta: React.FunctionComponent<ListMetaProps>;
export interface ListTrailIconProps {
	/**
	 * ML Icon name
	 */
	icon: string;
	/**
	 * Custom class name
	 */
	className?: string;
}
declare const ListTrailIcon: React.FunctionComponent<ListTrailIconProps>;
export interface ListActionProps {
	/**
	 * React children
	 */
	children?: React.ReactNode;
	/**
	 * Action Label
	 */
	label?: string;
	/**
	 * OnClick callback
	 */
	onClick?: () => void;
	/**
	 * Additional ClassNames
	 */
	className?: string;
}
declare const ListAction: React.FunctionComponent<ListActionProps>;
export declare type CompoundedList = typeof ListComponent & {
	Item: typeof ListItem;
	Label: typeof ListLabel;
	Meta: typeof ListMeta;
	TrailIcon: typeof ListTrailIcon;
	Action: typeof ListAction;
};
declare const ListCompounded: CompoundedList;
export interface ProgressProps {
	/**
	 * React children
	 */
	children?: React.ReactNode;
	/**
	 * Active Step (starts from 0)
	 */
	activeStep: number;
	/**
	 * Minimal Style
	 */
	minimal?: boolean;
	/**
	 * Dark UI
	 */
	dark?: boolean;
	/**
	 * Horizontal List Style
	 */
	horizontal?: boolean;
	/**
	 * Custom class name
	 */
	className?: string;
}
declare const Progress: React.FunctionComponent<ProgressProps>;
export interface ProgressStepProps {
	/**
	 * React children
	 */
	children?: React.ReactNode;
	/**
	 * Step's Index
	 */
	index?: number;
	/**
	 * Custom class name
	 */
	className?: string;
}
declare const ProgressStep: React.FunctionComponent<ProgressStepProps>;
export interface ProgressLabelProps {
	/**
	 * React children
	 */
	children?: React.ReactNode;
	/**
	 * Step Number
	 */
	index?: number;
	/**
	 * Is the step Active
	 */
	active?: boolean;
	/**
	 * Has the step Passed
	 */
	passed?: boolean;
	/**
	 * Custom class name
	 */
	className?: string;
}
declare const ProgressLabel: React.FunctionComponent<ProgressLabelProps>;
export interface ProgressContentProps {
	/**
	 * React children
	 */
	children?: React.ReactNode;
	/**
	 * Is Active
	 */
	active?: boolean;
	/**
	 * Custom class name
	 */
	className?: string;
}
declare const ProgressContent: React.FunctionComponent<ProgressContentProps>;
export declare type CompoundedProgress = typeof ProgressComponent & {
	Step: typeof ProgressStep;
	Label: typeof ProgressLabel;
	Content: typeof ProgressContent;
};
declare const ProgressCompounded: CompoundedProgress;
export interface RangePickerProps {
	/**
	 * Range Steps
	 * @default 1
	 */
	steps?: number;
	/**
	 * Start Number
	 */
	start: number;
	/**
	 * End Number
	 */
	end: number;
	/**
	 * Number of column
	 * @default 7
	 */
	columns?: number;
	/**
	 * Initial Selected Value
	 */
	value?: number;
	/**
	 * Show elevation
	 * @default true
	 */
	elevation?: boolean;
	/**
	 * Disable Selection
	 * @default false
	 */
	disabled?: boolean;
	/**
	 * Disable Selection Buttons
	 * @default []
	 */
	disabledValues?: number[];
	/**
	 * Callback for returning user selection
	 */
	onChange?: ((selection: number | undefined) => void) | undefined;
	/**
	 * Custom class name
	 */
	className?: string;
}
export declare const RangePicker: React.FunctionComponent<RangePickerProps>;
export interface CardProps {
	/**
	 * React children
	 */
	children?: React.ReactNode;
	/**
	 * Card background
	 */
	background?: {
		color?: string;
		image?: string;
		video?: string;
	};
	/**
	 * On card click
	 */
	onClick?: () => void;
	/**
	 * Custom class name
	 */
	className?: string;
	/**
	 * CSS Style
	 */
	style?: React.CSSProperties;
}
declare const Card: React.FunctionComponent<CardProps>;
export interface CardMediaProps {
	/**
	 * Media size
	 */
	size?: "Medium" | "Small";
	/**
	 * Image url
	 */
	image?: string;
	/**
	 * video url
	 */
	video?: string;
	/**
	 * Alternative text
	 */
	alt?: string;
	/**
	 * Custom class name
	 */
	className?: String;
}
declare const CardMedia: React.FunctionComponent<CardMediaProps>;
export interface CardChipProps {
	/**
	 * React children
	 */
	children: React.ReactNode;
	/**
	 * Background color
	 */
	background?: string;
	/**
	 * Text color
	 */
	color?: string;
	/**
	 * On click event
	 */
	onClick?: () => void;
	/**
	 * Custom class name
	 */
	className?: string;
}
declare const CardChip: React.FunctionComponent<CardChipProps>;
export interface CardSponsorProps {
	/**
	 * Sponsor name
	 */
	name: string;
	/**
	 * Sponsor logo
	 */
	logo: string;
	/**
	 * Custom class name
	 */
	className?: string;
}
declare const CardSponsor: React.FunctionComponent<CardSponsorProps>;
export interface CardImageIconProps {
	/**
	 * Icon's image url
	 */
	image?: string;
	/**
	 * border
	 */
	border?: boolean;
	/**
	 * MLIcon name
	 */
	icon?: string;
	/**
	 * Icon color
	 */
	color?: string;
	/**
	 * Background color
	 */
	background?: string;
	/**
	 * Custom class name
	 */
	className?: string;
}
declare const CardImageIcon: React.FunctionComponent<CardImageIconProps>;
export declare type CompoundedCard = typeof CardComponent & {
	Media: typeof CardMedia;
	Chip: typeof CardChip;
	Sponsor: typeof CardSponsor;
	ImageIcon: typeof CardImageIcon;
};
declare const CardCompounded: CompoundedCard;
export interface ContentCardProps {
	/**
	 * Card size
	 */
	size?: "Medium" | "Small";
	/**
	 * Card background
	 */
	background?: {
		color?: string;
	};
	/**
	 * Image url
	 */
	image?: string;
	/**
	 * video url
	 */
	video?: string;
	/**
	 * Overline content
	 */
	overline?: string;
	/**
	 * Title content
	 */
	title: string;
	/**
	 * Subtitle content
	 */
	subtitle: string;
	/**
	 * Chip title
	 */
	chipTitle?: string;
	/**
	 * Custom class name
	 */
	className?: string;
}
export declare const ContentCard: React.FunctionComponent<ContentCardProps>;
export interface MarketingCardProps {
	/**
	 * Card size
	 */
	size?: "Large" | "Medium" | "Small" | "Mini";
	/**
	 * Card background
	 */
	background?: {
		color?: string;
		image?: string;
		video?: string;
	};
	/**
	 * Image for the iconImage
	 */
	iconImage?: {
		image?: string;
		icon?: string;
		background?: string;
		color?: string;
	};
	/**
	 * Overline content
	 */
	overline?: string;
	/**
	 * Title content
	 */
	title: string;
	/**
	 * Subtitle content
	 */
	subtitle?: string;
	/**
	 * Content text color
	 */
	color?: string;
	/**
	 * Chip title
	 */
	chipTitle?: string;
	/**
	 * On click event
	 */
	onClick?: () => void;
	/**
	 * Custom class name
	 */
	className?: string;
}
export declare const MarketingCard: React.FunctionComponent<MarketingCardProps>;
export interface PFMCardProps {
	/**
	 * Card size
	 */
	size?: "Medium" | "Small";
	/**
	 * Image for the iconImage
	 */
	iconImage?: {
		image?: string;
		icon?: string;
		background?: string;
		color?: string;
	};
	/**
	 * Title content
	 */
	title: string;
	/**
	 * content
	 */
	content?: string;
	/**
	 * Subtitle content
	 */
	subtitle?: string;
	/**
	 * Custom class name
	 */
	className?: string;
}
export declare const PFMCard: React.FunctionComponent<PFMCardProps>;
export interface SponsoredCardProps {
	/**
	 * Card sponsor's details
	 */
	sponsor: {
		name: string;
		logo: string;
	};
	/**
	 * Overline content
	 */
	overline?: React.ReactNode;
	/**
	 * Title content
	 */
	title: React.ReactNode;
	/**
	 * Subtitle content
	 */
	subtitle: React.ReactNode;
	/**
	 * Image url
	 */
	image?: string;
	/**
	 * Video url
	 */
	video?: string;
	/**
	 * Chip title
	 */
	chipTitle?: string;
	/**
	 * Custom class name
	 */
	className?: string;
}
export declare const SponsoredCard: React.FunctionComponent<SponsoredCardProps>;
export interface DisplayProps extends TypographyProps {
	/**
	 * Text Size
	 */
	size?: Exclude<TextSize, "XXLarge" | "XSmall" | "XXSmall">;
}
export declare const Display: import("styled-components").StyledComponent<"h1", any, DisplayProps, never>;
export declare const Heading: import("styled-components").StyledComponent<"h3", any, TypographyProps, never>;
export interface ParagraphProps extends TypographyProps {
	/**
	 * Text Size
	 */
	size?: Exclude<TextSize, "XXLarge" | "XLarge">;
}
export declare const Paragraph: import("styled-components").StyledComponent<"p", any, ParagraphProps, never>;
export declare const GlobalStyle: GlobalStyleComponent<{}, DefaultTheme>;
/**
 * Semantic Color
 *
 * @readonly
 * @description
 * Collections of semantic colors that convey its use case,
 * that can be consumed internal and by end users.
 *
 * @see {@link https://moneylion.atlassian.net/wiki/spaces/Mobile/pages/1478066383/MoneyLion+Design+System+RFC#Semantic-Color}
 * @see {@link https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/color/} for concept inspiration
 *
 * @todo Add Dark Mode support once we upgraded React Native to ^0.62.0
 */
export declare const SEMANTIC_COLOR: Readonly<{
	FILL_TRANSPARENT: string;
	SHADOW_PRIMARY: string;
	BACKGROUND_PAGE: string;
	BACKGROUND_PAGE_ACCENT: string;
	BACKGROUND_PAGE_POSITIVE: string;
	BACKGROUND_PAGE_WARNING: string;
	BACKGROUND_PAGE_NEGATIVE: string;
	BACKGROUND_PAGE_DARK: string;
	BACKGROUND_CONTENT: string;
	BACKGROUND_CONTENT_ACCENT: string;
	BACKGROUND_CONTENT_POSITIVE: string;
	BACKGROUND_CONTENT_WARNING: string;
	BACKGROUND_CONTENT_NEGATIVE: string;
	BACKGROUND_CONTENT_DARK: string;
	BACKGROUND_OVERLAY_DARK: string;
	CONTENT_PRIMARY: string;
	CONTENT_SECONDARY: string;
	CONTENT_TERTIARY: string;
	CONTENT_DISABLED: string;
	CONTENT_ACCENT: string;
	CONTENT_NEGATIVE: string;
	CONTENT_WARNING: string;
	CONTENT_POSITIVE: string;
	CONTENT_ON_COLOR_PRIMARY: string;
	CONTENT_ON_COLOR_SECONDARY: string;
	CONTENT_ON_COLOR_TERTIARY: string;
	CONTENT_ON_COLOR_DISABLED: string;
	BUTTON_PRIMARY_BACKGROUND: string;
	BUTTON_PRIMARY_DISABLED_BACKGROUND: string;
	BUTTON_SECONDARY_BACKGROUND: string;
	BUTTON_SELECTED_BACKGROUND: string;
	BUTTON_SECONDARY_ON_COLOR_BACKGROUND: string;
	BUTTON_SELECTED_ON_COLOR_BACKGROUND: string;
	BORDER: string;
	BORDER_ON_COLOR: string;
	BACKGROUND_SNACKBAR: string;
	OVERLAY_HOVER: string;
	OVERLAY_FOCUSED: string;
	OVERLAY_PRESSED: string;
	OVERLAY_SELECTED: string;
	OVERLAY_INVERSE_HOVER: string;
	OVERLAY_INVERSE_FOCUSED: string;
	OVERLAY_INVERSE_PRESSED: string;
	OVERLAY_INVERSE_SELECTED: string;
	INPUT_BACKGROUND: string;
	INPUT_BACKGROUND_DARK: string;
	INPUT_LOADINGBASE: string;
	INPUT_LOADINGBASE_DARK: string;
	CODE_INPUT_BACKGROUND_DARK: string;
	CODE_INPUT_BACKGROUND_NEGATIVE: string;
	CODE_INPUT_BORDER_NEGATIVE: string;
	CODE_INPUT_BACKGROUND_POSITIVE: string;
	CODE_INPUT_BORDER_POSITIVE: string;
}>;

export {
	CardCompounded as Card,
	ChipCompounded as Chip,
	DialogCompounded as Dialog,
	ListCompounded as List,
	ProgressCompounded as ProgressList,
	SelectCompouned as Select,
};

export {};
